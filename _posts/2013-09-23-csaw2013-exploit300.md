---
title: CSAW-CTF-2013 - Exploit 300
date: 2013-09-23
tags: ctf
author: Tosh
layout: post
---

Voici un petit write-up pour l'exploit300 du CSAW CTF 2013.

Vous pouvez trouver le binaire ici : [exploit300](https://repo.t0x0sh.org/ctf/2013-csaw/exploit300)

On a un programme qui nous demande un nom d'utilisateur et un mot de passe. Après un petit coup de strings ou de GDB, on voit facilement que ce sont des chaines de caractères codées en dur dans le programme :

```
	$ strings ./fil_chal
	...
	Welcome!
	http://youtu.be/KmtzQCSh6xk
	csaw2013
	S1mplePWD
	...
```

Pour continuer l'exécution, il faut donc envoyer csaw2013 pour l'username et S1mplePWD pour password.

On remarque ensuite qu'on nous redemande une chaine de caractère, qui est ensuite passée à atoi(). Il s'agit de la taille passée en paramètre du prochain recv(). Seul la borne supérieur est checké, en envoyant une valeur négative, on peut aboutir à un stack based overflow.

```
	$ strace -f ./fil_chal
	...
	[pid 23721] send(4, "UserName: ", 10, 0) = 10
	[pid 23721] recv(4, "csaw2013\n", 9, 0) = 9
	[pid 23721] send(4, "Password: ", 10, 0) = 10
	[pid 23721] recv(4, "S1mplePWD\n", 10, 0) = 10
	[pid 23721] send(4, "Welcome!\nhttp://youtu.be/KmtzQCS"..., 38, 0) = 38
	[pid 23721] send(4, "Entry Info: ", 12, 0) = 12
	[pid 23721] read(4, "42\n", 10)         = 3
	[pid 23721] recv(4, "test\n", 42, 0)    = 5
	...
```

La suite n'est pas compliquée étant donnée que .bss est +RWX :
On jump sur recv@PLT, en passant en paramètre l'adresse de .bss, puis on envoit notre shellcode. On a plus qu'à jumper sur .bss pour exécuter notre payload !

Le shellcode est un simple cat("./key") utilisant des syscalls, et réutilisant la socket (fd=4).

L'exploit est sur github : [exploit300.pl](https://github.com/t00sh/ctf/blob/master/csaw_ctf_2013/exploit300.pl)



Il n'y avait pas tellement de difficulté dans ce challenge pour ceux qui ont l'habitude des failles applicatives...
